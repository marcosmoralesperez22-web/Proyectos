<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Post Mortem: Vengeance</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Courier New", Courier, monospace;
        color: #fff;
        user-select: none;
      }
      #game-ui {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: none;
      }
      #main-menu {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
      }
      h1 {
        font-size: 4rem;
        color: #e74c3c;
        text-shadow: 0 0 10px #c0392b;
        margin-bottom: 20px;
        text-transform: uppercase;
        letter-spacing: 5px;
      }
      button {
        background: #333;
        color: #fff;
        border: 2px solid #e74c3c;
        padding: 15px 30px;
        font-size: 1.5rem;
        cursor: pointer;
        margin: 10px;
        transition: all 0.3s;
        font-family: inherit;
        text-transform: uppercase;
      }
      button:hover {
        background: #e74c3c;
        color: #000;
        box-shadow: 0 0 15px #e74c3c;
      }
      #hud {
        position: absolute;
        top: 20px;
        left: 20px;
        font-size: 1.2rem;
        text-shadow: 1px 1px 2px #000;
      }
      .bar-container {
        width: 300px;
        height: 20px;
        background: #333;
        margin-bottom: 10px;
        border: 1px solid #555;
        position: relative;
      }
      .bar {
        height: 100%;
        transition: width 0.2s;
      }
      #player-health-bar {
        background: #2ecc71;
        width: 100%;
      }
      #boss-health-bar {
        background: #e74c3c;
        width: 100%;
      }
      .bar-label {
        position: absolute;
        top: -20px;
        left: 0;
        font-weight: bold;
      }
      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      #crosshair::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 4px;
        background: #fff;
        transform: translate(-50%, -50%);
        border-radius: 50%;
      }
      #editor {
        margin-top: 20px;
        border: 1px solid #444;
        padding: 20px;
        background: rgba(20, 20, 20, 0.8);
        text-align: center;
      }
      #preview-container {
        width: 200px;
        height: 200px;
        background: #111;
        margin: 10px auto;
        border: 1px solid #333;
      }
      input[type="color"] {
        cursor: pointer;
      }
      #game-over-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 20;
      }
      #game-over-title {
        font-size: 5rem;
        margin-bottom: 20px;
      }
      .win {
        color: #f1c40f;
        text-shadow: 0 0 20px #f39c12;
      }
      .lose {
        color: #c0392b;
        text-shadow: 0 0 20px #e74c3c;
      }
      #instructions {
        margin-top: 20px;
        color: #aaa;
        font-size: 0.9rem;
      }
    </style>
    <!-- Three.js CDN -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="main-menu">
      <h1>Post Mortem: Vengeance</h1>
      <div id="editor">
        <h3>Editor de Personaje</h3>
        <div id="preview-container"></div>
        <label
          >Color del Traje: <input type="color" id="suit-color" value="#3498db"
        /></label>
      </div>
      <button id="start-btn">Jugar</button>
      <div id="instructions">
        WASD: Mover | ESPACIO: Saltar | CLICK: Disparar | RATÓN: Mirar
      </div>
    </div>

    <div id="game-ui">
      <div id="hud">
        <div class="bar-container">
          <div class="bar-label">MARCOS (TÚ)</div>
          <div class="bar" id="player-health-bar"></div>
        </div>
        <div class="bar-container" id="boss-hud" style="display: none">
          <div class="bar-label">SUA (JEFE)</div>
          <div class="bar" id="boss-health-bar"></div>
        </div>
      </div>
      <div id="crosshair"></div>
    </div>

    <div id="game-over-screen">
      <h1 id="game-over-title"></h1>
      <button id="restart-btn">Volver al Menú</button>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

      // --- Global Variables ---
      let camera, scene, renderer, controls;
      let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false,
        canJump = false;
      let prevTime = performance.now();
      let velocity = new THREE.Vector3();
      let direction = new THREE.Vector3();
      let raycaster;

      // Game State
      let gameActive = false;
      let playerHealth = 100;
      let bossHealth = 1000;
      let bossPhase = 1;
      let projectiles = [];
      let bossProjectiles = [];
      let lastShotTime = 0;
      const SHOOT_COOLDOWN = 200; // ms

      // Entities
      let boss;
      let playerMesh; // For preview
      let worldObjects = []; // For collision (walls, floor)
      let easterEggFound = false;

      // DOM Elements
      const startBtn = document.getElementById("start-btn");
      const restartBtn = document.getElementById("restart-btn");
      const mainMenu = document.getElementById("main-menu");
      const gameUI = document.getElementById("game-ui");
      const gameOverScreen = document.getElementById("game-over-screen");
      const suitColorInput = document.getElementById("suit-color");
      const previewContainer = document.getElementById("preview-container");
      const playerHealthBar = document.getElementById("player-health-bar");
      const bossHealthBar = document.getElementById("boss-health-bar");
      const bossHud = document.getElementById("boss-hud");

      // --- Initialization ---
      init();
      animate();

      function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.y = 1.6; // Eye level

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Controls
        controls = new PointerLockControls(camera, document.body);

        // Listeners
        startBtn.addEventListener("click", startGame);
        restartBtn.addEventListener("click", resetGame);

        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);
        document.addEventListener("mousedown", onMouseDown);

        controls.addEventListener("lock", () => {
          // Game resumed
        });
        controls.addEventListener("unlock", () => {
          if (gameActive && playerHealth > 0 && bossHealth > 0) {
            // Pause menu could go here, for now just cursor shows
          }
        });

        window.addEventListener("resize", onWindowResize);

        // Character Preview in Menu
        initPreview();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const moonLight = new THREE.DirectionalLight(0x6688cc, 0.5);
        moonLight.position.set(50, 100, 50);
        moonLight.castShadow = true;
        scene.add(moonLight);

        // Generate World
        generateWorld();
      }

      function initPreview() {
        const w = previewContainer.clientWidth;
        const h = previewContainer.clientHeight;
        const previewScene = new THREE.Scene();
        previewScene.background = new THREE.Color(0x222);
        const previewCamera = new THREE.PerspectiveCamera(50, w / h, 0.1, 100);
        previewCamera.position.z = 3;
        previewCamera.position.y = 1;

        const previewRenderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true,
        });
        previewRenderer.setSize(w, h);
        previewContainer.appendChild(previewRenderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 2);
        previewScene.add(light);
        previewScene.add(new THREE.AmbientLight(0x404040));

        // Simple Player Model for Preview
        const geometry = new THREE.CapsuleGeometry(0.4, 1, 4, 8);
        const material = new THREE.MeshStandardMaterial({
          color: suitColorInput.value,
        });
        playerMesh = new THREE.Mesh(geometry, material);
        previewScene.add(playerMesh);

        suitColorInput.addEventListener("input", (e) => {
          playerMesh.material.color.set(e.target.value);
        });

        function animatePreview() {
          requestAnimationFrame(animatePreview);
          playerMesh.rotation.y += 0.02;
          previewRenderer.render(previewScene, previewCamera);
        }
        animatePreview();
      }

      function generateWorld() {
        // Floor
        const floorGeo = new THREE.PlaneGeometry(200, 200);
        const floorMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.8,
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        worldObjects.push(floor);

        // Ruins / Columns
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const boxMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

        for (let i = 0; i < 50; i++) {
          const h = Math.random() * 5 + 2;
          const w = Math.random() * 2 + 1;
          const d = Math.random() * 2 + 1;
          const mesh = new THREE.Mesh(boxGeo, boxMat);
          mesh.position.set(
            (Math.random() - 0.5) * 100,
            h / 2,
            (Math.random() - 0.5) * 100
          );
          // Keep center clear for boss fight
          if (mesh.position.length() < 15) continue;

          mesh.scale.set(w, h, d);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
          worldObjects.push(mesh);
        }

        // Easter Egg: Tomb
        const tombGeo = new THREE.BoxGeometry(1, 1.5, 0.5);
        const tombMat = new THREE.MeshStandardMaterial({ color: 0x555 });
        const tomb = new THREE.Mesh(tombGeo, tombMat);
        tomb.position.set(40, 0.75, -40);
        tomb.castShadow = true;
        scene.add(tomb);
        worldObjects.push(tomb);

        // Simple text representation (floating sprite or just knowledge)
        // Gold Object
        const goldGeo = new THREE.IcosahedronGeometry(0.5);
        const goldMat = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          metalness: 1,
          roughness: 0.2,
        });
        const goldObj = new THREE.Mesh(goldGeo, goldMat);
        goldObj.position.set(40, 0.5, -38);
        goldObj.name = "gold";
        scene.add(goldObj);

        // Boss (SUA)
        createBoss();
      }

      function createBoss() {
        const bossGroup = new THREE.Group();

        // Body
        const bodyGeo = new THREE.DodecahedronGeometry(2);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x222 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 2;
        bossGroup.add(body);

        // Head
        const headGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
        const head = new THREE.Mesh(headGeo, bodyMat);
        head.position.y = 4;
        bossGroup.add(head);

        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.2);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-0.3, 4.2, 0.5);
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(0.3, 4.2, 0.5);
        bossGroup.add(leftEye);
        bossGroup.add(rightEye);

        // Arms
        const armGeo = new THREE.CylinderGeometry(0.5, 0.5, 3);
        const leftArm = new THREE.Mesh(armGeo, bodyMat);
        leftArm.position.set(-2.5, 2.5, 0);
        leftArm.rotation.z = 0.5;
        const rightArm = new THREE.Mesh(armGeo, bodyMat);
        rightArm.position.set(2.5, 2.5, 0);
        rightArm.rotation.z = -0.5;
        bossGroup.add(leftArm);
        bossGroup.add(rightArm);

        bossGroup.position.set(0, 0, -20);
        scene.add(bossGroup);

        boss = {
          mesh: bossGroup,
          bodyMat: bodyMat,
          eyeMat: eyeMat,
          health: 1000,
          speed: 5,
          state: "idle",
          phase: 1,
          lastAttack: 0,
          velocity: new THREE.Vector3(),
        };
      }

      function startGame() {
        mainMenu.style.display = "none";
        gameUI.style.display = "block";
        bossHud.style.display = "block";
        controls.lock();
        gameActive = true;
        playerHealth = 100;
        bossHealth = 1000;
        bossPhase = 1;
        updateHUD();

        // Reset positions
        camera.position.set(0, 1.6, 20);
        boss.mesh.position.set(0, 0, -20);
        boss.health = 1000;
        boss.mesh.visible = true;

        // Apply chosen color to something? Maybe hands if we had them.
        // For now, the user knows they are that color.
      }

      function resetGame() {
        gameOverScreen.style.display = "none";
        mainMenu.style.display = "flex";
        gameUI.style.display = "none";
      }

      function onKeyDown(event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = true;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = true;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = true;
            break;
          case "Space":
            if (canJump === true) velocity.y += 350; // Jump force
            canJump = false;
            break;
        }
      }

      function onKeyUp(event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = false;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = false;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = false;
            break;
        }
      }

      function onMouseDown(event) {
        if (!gameActive || !controls.isLocked) return;

        const now = performance.now();
        if (now - lastShotTime > SHOOT_COOLDOWN) {
          shoot();
          lastShotTime = now;
        }
      }

      function shoot() {
        const projectileGeo = new THREE.SphereGeometry(0.1);
        const projectileMat = new THREE.MeshBasicMaterial({
          color: suitColorInput.value,
        }); // Player color
        const projectile = new THREE.Mesh(projectileGeo, projectileMat);

        projectile.position.copy(camera.position);

        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);

        projectile.userData = { velocity: direction.multiplyScalar(50) }; // Speed
        scene.add(projectile);
        projectiles.push(projectile);
      }

      function updateHUD() {
        playerHealthBar.style.width = Math.max(0, playerHealth) + "%";
        bossHealthBar.style.width =
          Math.max(0, (boss.health / 1000) * 100) + "%";
      }

      function gameOver(win) {
        gameActive = false;
        controls.unlock();
        gameUI.style.display = "none";
        gameOverScreen.style.display = "flex";
        const title = document.getElementById("game-over-title");
        if (win) {
          title.innerText = "¡VICTORIA!";
          title.className = "win";
        } else {
          title.innerText = "HAS MUERTO";
          title.className = "lose";
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();

        if (controls.isLocked === true && gameActive) {
          const delta = (time - prevTime) / 1000;

          // --- Player Movement ---
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;
          velocity.y -= 9.8 * 100.0 * delta; // Gravity

          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize();

          if (moveForward || moveBackward)
            velocity.z -= direction.z * 400.0 * delta;
          if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

          controls.moveRight(-velocity.x * delta);
          controls.moveForward(-velocity.z * delta);
          camera.position.y += velocity.y * delta; // Apply gravity to Y

          // Floor Collision
          if (camera.position.y < 1.6) {
            velocity.y = 0;
            camera.position.y = 1.6;
            canJump = true;
          }

          // --- Projectiles ---
          for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            p.position.addScaledVector(p.userData.velocity, delta);

            // Remove if too far
            if (p.position.distanceTo(camera.position) > 100) {
              scene.remove(p);
              projectiles.splice(i, 1);
              continue;
            }

            // Hit Boss
            const dist = p.position.distanceTo(boss.mesh.position);
            if (dist < 3) {
              // Hitbox radius
              boss.health -= 10; // Damage
              scene.remove(p);
              projectiles.splice(i, 1);

              // Flash boss
              boss.bodyMat.emissive.setHex(0xff0000);
              setTimeout(() => {
                boss.bodyMat.emissive.setHex(0x000000);
              }, 50);

              if (boss.health <= 0) {
                boss.mesh.visible = false;
                gameOver(true);
              }
              continue;
            }
          }

          // --- Boss AI ---
          if (boss.health > 0) {
            const distToPlayer = boss.mesh.position.distanceTo(camera.position);

            // Phases
            if (boss.health < 300) {
              bossPhase = 3;
              boss.bodyMat.color.setHex(0x880000); // Red fury
              boss.speed = 12;
            } else if (boss.health < 700) {
              bossPhase = 2;
              boss.speed = 8;
            } else {
              bossPhase = 1;
              boss.speed = 5;
            }

            // Movement (Chase)
            const lookDir = new THREE.Vector3()
              .subVectors(camera.position, boss.mesh.position)
              .normalize();
            lookDir.y = 0; // Keep upright

            // Simple "look at"
            boss.mesh.lookAt(
              camera.position.x,
              boss.mesh.position.y,
              camera.position.z
            );

            if (distToPlayer > 5) {
              boss.mesh.position.addScaledVector(lookDir, boss.speed * delta);
            }

            // Attacks
            if (bossPhase >= 2 && Math.random() < 0.01) {
              // Jump logic could go here
              boss.mesh.position.y += 2; // Pop up
              setTimeout(() => {
                boss.mesh.position.y = 0;
              }, 500);
            }

            if (bossPhase === 3 && time - boss.lastAttack > 1000) {
              // Throw rock
              const rock = new THREE.Mesh(
                new THREE.DodecahedronGeometry(0.5),
                new THREE.MeshStandardMaterial({ color: 0x553311 })
              );
              rock.position.copy(boss.mesh.position);
              rock.position.y += 3;
              rock.userData = { velocity: lookDir.clone().multiplyScalar(30) };
              scene.add(rock);
              bossProjectiles.push(rock);
              boss.lastAttack = time;
            }

            // Collision with Player
            if (distToPlayer < 3) {
              playerHealth -= 1; // Constant damage if touching
            }
          }

          // --- Boss Projectiles ---
          for (let i = bossProjectiles.length - 1; i >= 0; i--) {
            const bp = bossProjectiles[i];
            bp.position.addScaledVector(bp.userData.velocity, delta);

            if (bp.position.distanceTo(camera.position) < 1.5) {
              playerHealth -= 20;
              scene.remove(bp);
              bossProjectiles.splice(i, 1);
            } else if (bp.position.length() > 100) {
              scene.remove(bp);
              bossProjectiles.splice(i, 1);
            }
          }

          // Check Death
          if (playerHealth <= 0) {
            gameOver(false);
          }

          updateHUD();
        }

        prevTime = time;
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
